問題1
puts hash.keys
puts hash.values
上記のメソッドを実行した時に

one
two
three
1
2
3
とターミナルに表示されるような変数hashを作成するためのコードをシンボルを使って記述してください。

----------------------------------------------------------------------------------

hash = { one:1, two:2, three:3 }


問題2
配列の内部に、複数のユーザーの情報をハッシュとして持つ変数user_dataがあります。
user_data = [
 {user: {profile: {name: 'George'}}},
 {user: {profile: {name: 'Alice'}}},
 {user: {profile: {name: 'Taro'}}},
]
user_dataを利用して、全てのユーザーの名前だけが出力されるようにRubyでコーディングしてください。
ただし、出力結果は次のようになるものとします。

George
Alice
Taro

------------------------------------------------------------------------------------

user_data.each do |u|
    puts u[:user][:profile][:name]
end

別解

user_data.each{ |u| puts u.dig(:user, :profile, :name) }


問題3
class Article

  def initialize(author, title, content)
    @author = author
    @title = title
    @content = content
  end

end
上記のコードに追加を行い、以下の出力結果を得られるようにしてください。ただし、クラスとインスタンスを使用するものとします。

著者: 阿部
タイトル: Rubyの素晴らしさについて
本文: Awesome Ruby!


------------------------------------------------------------------------------------------------------------
class Article

  def initialize(author, title, content)
    @author = author
    @title = title
    @content = content
  end

  def author
    @author
  end

  def title
    @title
  end

  def content
    @content
  end

end

article = Article.new("阿部", "Rubyの素晴らしさについて", "Awesome Ruby!")
puts "著者: #{article.author}"
puts "タイトル: #{article.title}"
puts "本文: #{article.content}"

問題4
今日の曜日を表示するコードをDateクラスを使用して記述してください。

ただし、金曜日だった場合だけ以下のように表示の内容を変えてください。

（出力内容）
「今日は月曜日」
「今日は金曜日だ ！！！」

ヒント
 Dateクラス
DateクラスとはRubyの標準ライブラリの機能です。Dateクラスを使うには以下一文を記述します。


require "date"
次に、Dateクラスを用いて「今日の曜日」を取得する場合は以下のように記述します。

Date.today.wday
wdayは曜日を0(日曜日)から6(土曜日)の整数で取得することができるDateクラスに用意されているメソッドです。

たとえば、以下のように使うことができます。

require "date"

day = Date.today.wday

puts day
これを実行すると、曜日に合わせた数字が出力されます。たとえば、木曜日だとすれば4が出力されることになります。

---------------------------------------------------------------------------------------------------

day = Date.today.wday
days = ["日曜日", "月曜日", "火曜日", "水曜日", "木曜日", "金曜日", "土曜日"]

if day == 5
  puts "今日は#{days[day]}だ！！！"
else
  puts "今日は#{days[day]}"
end

問題5
次のif文をunlessというメソッドを用いて書き換えてください。


if a + b > 0
  puts "計算結果は0より大きいです"
end
ヒント
unless
unlessとはifとは逆で、条件式がfalseの場合に処理が実行されます。
unlessの詳細は公式リファレンスを確認しましょう。

ifを使用した場合
if 条件式
  条件式がtrueの時に実行する処理
else
  条件式がfalseの時に実行する処理
end
unlessを使用した場合
unless 条件式
  条件式がfalseの時に実行する処理
else
  条件式がtrueの時に実行する処理
end

ーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー

unless a + b <= 0
  puts "計算結果は0より大きいです"
end


問題6
次の要件を満たすプログラムを実装しましょう。

1~10の数値を順番に足し合わせる
足し算の合計値がターミナルに出力される
しかし、以下のような順番に並べて、足し算しただけのプログラムはNGです。

sum = 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10
ループ処理を用いて実装しましょう。

ヒント
times文を用いることで、ループ処理を実装できます。
ループ処理とは、特定の条件下にて、任意の処理を繰り返すことでした。
今回の問題にループ処理を当てはめると、

0に1を足し、
その結果に2を足し、
その結果に3を足し、
その結果に4を足し、
その結果に5を足し、
...と10まで繰り返していきます。

ーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー
sum = 0

10.times do |i|
  sum = sum + i + 1
end

puts sum


別解
sum = 0

10.times do |i|
  sum += i + 1
end

puts sum


問題7
以下の配列から任意の数字を探して何番目に含まれているかという結果を返すsearchメソッドを、each_with_indexを用いて作成しましょう。


input = [3, 5, 9 ,12, 15, 21, 29, 35, 42, 51, 62, 78, 81, 87, 92, 93]
雛形
以下の雛形のコードを参考に解答しましょう。


def search(target_num, input)
  # 処理を記述
end

input = [3, 5, 9 ,12, 15, 21, 29, 35, 42, 51, 62, 78, 81, 87, 92, 93]
# 呼び出し例
search(11, input)
出力例
search(5, input) → 2番目にあります
search(12, input) → 4番目にあります
search(7, input) → その数は含まれていません

ヒント
 each_with_index
each_with_indexは、Rubyに標準で組み込まれているメソッドの1つです。要素の繰り返し処理と同時に、その要素が何番目に処理されたのかも表すことができます。

以下のように書きます。


配列名.each_with_index  do |item, i|

end
具体的には以下のように使うことができます。


fruits = ["メロン", "バナナ", "アップル"]

fruits.each_with_index do |item, i|
 puts "#{i}番目のフルーツは、#{item}です。"
end
これを実行すると、以下のような出力結果が得られます。


0番目のフルーツは、メロンです。
1番目のフルーツは、バナナです。
2番目のフルーツは、アップルです。

ーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー

def search(target_num, input)

  input.each_with_index do |num, index|
    if num == target_num
      puts "#{index + 1}番目にあります"
      return
    end
  end
  puts "その数は含まれていません"
end

input = [3, 5, 9 ,12, 15, 21, 29, 35, 42, 51, 62, 78, 81, 87, 92, 93]
search(11, input)


問題8
概要
本ドリルでは、対象の文字列の中に特定の値が含まれているかどうかを検知するプログラムを実装します。


以下の要件を満たすcheck_nameメソッドを実装しましょう。

名前を入力すると「登録が完了しました」という文字列を出力すること
名前の中にピリオド(.)がある場合は、「 "!エラー!記号は登録できません"」という文字列を出力すること
名前の中に空白（半角のみ）がある場合は、「 "!エラー!空白は登録できません"」という文字列を出力すること
※今回空白に関しては、半角スペースのみを考えることとします。

雛形

def check_name(str) 
  # 処理を記述
end

puts "登録したい名前を入力してください(例)YamadaTaro"
str = gets
check_name(str) 
出力例
YamadaTaro → 登録が完了しました
Yamada.Taro→!エラー!記号は登録できません
Yamada Taro → !エラー!空白は登録できません

ヒント
include?メソッドを使用しましょう。

include?メソッド
include?メソッドは、指定した値が配列や文字列内に含まれているかを判定するメソッドです。指定した値が含まれている場合はtrueを、含まれていない場合はfalseを返り値として返します。

【例】

array = ["foo", "bar"]
puts array.include?("bar")
# => true
puts array.include?("hoge")
# => false

ーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー

def check_name(str) 
  if str.include?(".")
    puts "!エラー!記号は登録できません"
  elsif str.include?(" ")
    puts "!エラー!空白は登録できません"
  else
    puts "登録が完了しました"
  end
end
puts "登録したい名前を入力してください(例)YamadaTaro"
str = gets
check_name(str) 


問題9
ターミナルから数字を入力して、数字に応じて以下のように出力するプログラムを書いてください。

10以下なら10以下の数字です
10より大きい数値なら10より大きい数字です
10以下でかつ0以下なら0以下の数字です
ソースコードは以下の雛形を使ってください。


input = gets.to_i

----------------------------------------------------------------------------------------


input = gets.to_i

if input <= 0
  puts "0以下の数字です"
elsif
   input <= 10
  puts "10以下の数字です"
else
  puts "10より大きい数字です"
end


問題10
以下のように、果物の名前と値段が入った配列があります。
この配列を用いて、果物の名前とそれぞれの合計額が出力される
コードを記述してください。


fruits_price = [["apple", [200, 250, 220]], ["orange", [100, 120, 80]], ["melon", [1200, 1500]]]


（出力）
appleの合計金額は670円です
orangeの合計金額は300円です
melonの合計金額は2700円です

ーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー

fruits_price = [["apple", [200, 250, 220]], ["orange", [100, 120, 80]], ["melon", [1200, 1500]]]

fruits_price.each do |fruit|
  sum = 0
  fruit[1].each do |price|
    sum += price
  end
  puts "#{fruit[0]}の合計金額は#{sum}円です"
end


問題11
概要
本ドリルでは、指定された数値の範囲による条件と真偽値による条件を組み合わせて処理を行うプログラムを実装します。

問題
以下の要件を満たす in1to10メソッドを実装しましょう。

第一引数のnumが1以上かつ10以下の範囲であればTrueを出力すること
第二引数のoutside_modeがTrueの場合は、第一引数numが条件範囲外でもTrueを出力すること
それ以外はFalseを出力すること
雛形

def in1to10(num, outside_mode)
  # ここに条件式を記述する
end

# 呼び出し例
in1to10(5,false)
in1to10(11,false) 
in1to10(11,true) 
出力例
in1to10(5,false) →True
in1to10(11,false) →False
in1to10(11,true) →True

ヒント
 論理演算子
論理演算子とは、式の「真（True）」と「偽（False）」の確認や演算を行う際に用いられる演算子（記号、符号）のことです。以下のように条件分岐を実装する際、条件式に複数の条件を組み合わせるために用いられます。


if ( 【複数の条件が含まれる条件式】 )

end
複数の条件式を組み合わせた複雑な条件式を記述するために論理演算子&&と||を使います。

条件式aと条件式bを組み合わせる場合は以下のように記述します。



# aもbもtrueの場合にtrue
a && b 

# aかbのどちらかがtrueの場合にtrue
a || b 
なおRubyの論理演算子では、左辺から右辺に条件式を評価します。もし式全体の評価が確定した場合は、その時点で残りの評価を行いません。

したがって、上の例で言えば、a&&bにおいてaがfalseの時点で全体がfalseと確定するため、bの判定は行いません。また、a||bでは、aがtrueの時点で全体がtrueと確定するため、bの判定は行いません。

ーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー

def in1to10(num, outside_mode)
  if (num >= 1 && num <= 10) || outside_mode == True
    puts "True"
  else
    puts "False"
  end
end

# 呼び出し例
in1to10(5,false)
in1to10(11,false) 
in1to10(11,true) 


問題12

クラスFruitを以下の仕様で定義してください。

インスタンス
インスタンス名    名前        価格
apple          リンゴ       120
orange         オレンジ      200
strawbery      イチゴ        60


インスタンス変数
・name
・price


クラスメソッド
メソッド名         処理
fresh            「採れたて新鮮な果実です」と表示


インスタンスメソッド
メソッド名         処理
initialize       引数で名前と価格を渡し、インスタンス変数nameとpriceに代入
introduce       「【名前】は【価格】円です」と表示



実行結果は以下のようになります。


採れたて新鮮な果実です
リンゴは120円です
オレンジは200円です
イチゴは60円です
雛形
作ってもらうプログラムのひな形は以下です。


class Fruit
 def クラスメソッド
   # 正しくメソッドを定義した上で、ここに処理を記入してください
 end

 def initialize
   # ここに処理を記入してください
 end

 def インスタンスメソッド
   # 正しくメソッドを定義した上で、ここに処理を記入してください
 end
end


# 3つのインスタンスを生成してください

# クラスメソッドを呼び出し、「採れたて新鮮な果実です」と表示してください
# インスタンス毎にインスタンスメソッドを呼び出し、「【名前】は【価格】円です」と表示してください

ーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー

class Fruit

 def self.fresh
   puts "採れたて新鮮な果実です"
 end

 def initialize(name, price)
   @name = name
   @price = price
 end

 def introduce
   puts "#{@name}は#{@price}円です"
 end
end

apple = Fruit.new("リンゴ", 120)
orange = Fruit.new("オレンジ", 200)
strawberry = Fruit.new("イチゴ", 60)

Fruit.fresh
apple.introduce
orange.introduce
strawberry.introduce


問題13

概要
本ドリルでは、対象となる文字列から任意の文字を削除したのち、残った文字列を出力するプログラムを実装します。

問題
以下の要件を満たすmissing_charメソッドを実装しましょう。

対象となる文字列からn番目の文字を削除すること
削除された文字以外の文字列を出力すること
雛形

def missing_char(str, n)
  # 処理を記述
end

# 呼び出し例（1つ目の引数には対象となる文字列を、2つ目の引数には対象となる文字列から何番目の文字を削除するのかを指定しましょう）
missing_char('kitten', 1)
出力例：
missing_char('kitten', 1) → 'itten'
missing_char('kitten', 2) → 'ktten'
missing_char('kitten', 4) → 'kiten'

ヒント
slice!メソッドを使用しましょう。

 slice!メソッド
slice!メソッドは、配列や文字列から指定した要素を削除し、削除した後の要素を返すメソッドです。末尾にエクスクラメーションマーク(!)のつくメソッドを破壊的メソッドといいます。これはもとの配列や文字列を変化させるメソッドです。


string = "abcdefg"
string.slice!(2)

puts string
#=> "abdefg"
# 2番目の要素のcが取り除かれている
slice!メソッドの詳細は公式ドキュメントを確認しましょう。


ーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー


def missing_char(str, n)
  str.slice!(n - 1)
  puts str
end

# 呼び出し例
missing_char('kitten', 1)


問題14

概要
本ドリルでは、2つの条件を組み合わせた条件式を持つプログラムを実装します。

問題
以下の要件を満たす police_troubleメソッドを実装しましょう。

あなたは警官です。aとb二人の容疑者の取り調べをしています。このとき、次のルールで証言の真偽判定を行います。
※問題文で登場したaとb二人の容疑者は、今回実装するpolice_troubleメソッドの引数として取り扱っていきます。

第一引数aと第二引数bどちらの証言も真(true)であれば、Trueを出力すること
第一引数aと第二引数bどちらの証言も偽(false)であれば、Trueを出力すること
第一引数aと第二引数bで証言の真偽が一致しない場合であれば、Falseを出力すること
雛形

def police_trouble(a, b)
  # ここに条件式を記述する
end

# 呼び出し例
police_trouble(true, true) 
police_trouble(false, false)
police_trouble(true, false) 
出力例
police_trouble(true, true) → True
police_trouble(false, false) → True
police_trouble(true, false) → False

ヒント
 論理演算子
論理演算子とは、式の「真（True）」と「偽（False）」の確認や演算を行う際に用いられる演算子（記号、符号）のことです。以下のように条件分岐を実装する際、条件式に複数の条件を組み合わせるために用いられます。


if ( 【複数の条件が含まれる条件式】 )

end
複数の条件式を組み合わせた複雑な条件式を記述するために論理演算子&&、||、!を使います。
以下のように使用します。


# aもbもtrueの場合にtrue 
a && b

# aかbのどちらかがtrueの場合にtrue
a || b 

# aがtrueの場合にfalse、aがfalseの場合にtrue
!a

ーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー

def police_trouble(a, b)
  if (a && b) || (!a && !b)
    puts "True"
  else
    puts "False"
  end
end

# 呼び出し例
police_trouble(true, true) 
police_trouble(false, false)
police_trouble(true, false) 
出力例
police_trouble(true, true) → True
police_trouble(false, false) → True
police_trouble(true, false) → False


問題15

概要
本ドリルでは、対象となる文字列から特定の文字列の数を算出し、その数を出力するプログラムを実装します。

問題
以下の要件を満たすcount_hiメソッドを実装しましょう。

対象となる文字列の中から、"hi"という特定の文字列の数を取得すること
上記で取得した数を出力すること
雛形

def count_hi(str)
  #  処理を記述
end

# 呼び出し例（引数には対象となる文字列を指定します）
count_hi('abc hi ho')
出力例：
count_hi('abc hi ho') → 1
count_hi('ABChi hi') → 2
count_hi('hihi') → 2

ヒント
scanメソッドを使用しましょう。

scanメソッド
scanメソッドは、対象の要素から引数で指定した文字列を数え、配列として返すメソッドです。


"foobarbazfoobarbaz".scan("ba")
=> ["ba", "ba", "ba", "ba"]
scanメソッドの詳細は公式リファレンスを確認しましょう。

ーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー

def count_hi(str)
  puts str.scan('hi').length
end

# 呼び出し例（引数には対象となる文字列を指定します）
count_hi('abc hi ho')
出力例：
count_hi('abc hi ho') → 1
count_hi('ABChi hi') → 2
count_hi('hihi') → 2


問題16

任意の文字列に"code"が、左から何文字目に出てくるかを返し、その数を出力するメソッドを作りましょう。

出力例：
count_code("codexxcode") → 1
count_code("aaacodebbb") → 4
count_code("cozexxcode") → 7

ヒント: indexメソッドを使用しましょう
 index
indexメソッドは、文字列や配列の中に指定した文字列が含まれていた場合、その文字列の開始位置を整数の値で返します。

indexメソッドの詳細は公式リファレンスを確認しましょう。


str.index(検索したい文字列, [検索を開始する位置])

ーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー

def count_code(str)
  puts str.index("code", 0) + 1
end

別解

def count_code(str)
  puts (str.index("code") + 1)
end


問題17

概要
本ドリルでは、指定された範囲の数値によって処理が異なるプログラムを実装します。

問題
以下の要件を満たすparrot_troubleメソッドを実装しましょう。

最近、あなたはオウムを飼いはじめました。しかし、近隣から「夜にオウムの鳴き声がうるさい」と苦情がくるようになりました。あなたはこれをシステムで解決しようと考え、次のようなプログラムの要件を考えました。

第一引数にオウムが鳴く場合はtrueを指定し、鳴かないfalseを指定する
第二引数には時間を指定する（ただし、「分」は考えないものとする）
20時から翌朝7時までの間にオウムが鳴いた場合は「NG」と出力する（20時と7時は含まれない）
上記以外の場合は「OK」と出力する
雛形

def parrot_trouble(talking, hour)
  # ここに条件式を実装する
end

# 呼び出し例
parrot_trouble(true, 6)
出力例
parrot_trouble(true, 6) → NG
parrot_trouble(true, 7) → OK
parrot_trouble(false, 6) → OK
parrot_trouble(false, 7) → OK

ーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー

def parrot_trouble(talking, hour)
  if talking && (hour < 7 || hour > 20)
    puts "NG"
  else
    puts "OK"
  end
end

# 呼び出し例
parrot_trouble(true, 6)


問題18

配列にある値の中から偶数の数をカウントして出力するメソッドを作りましょう。

出力例：
count_evens([2, 1, 2, 3, 4]) → 3
count_evens([2, 2, 0]) → 3
count_evens([1, 3, 5]) → 0

ヒント
even?というメソッドを使いましょう。

even?メソッド
Rubyが元々用意している、対象の数値が偶数かどうかを判断するメソッドです。
対象の要素の値が偶数であれば真を返し、そうでない場合は偽を返します。

even?メソッドの詳細は公式リファレンスを確認しましょう。


10.even?
#=> true

5.even?
#=> false

ーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー

def count_evens(nums)
  count = 0
  nums.each do |num|
    if num.even?
      count += 1
    end
  end
  puts count
end


問題19

概要
本ドリルでは、特定の数字が存在するかどうかを判定するプログラムを実装します。

問題
以下の要件を満たすarray123メソッドを実装しましょう。

配列内に1,2,3が全て入っている場合は、「True」と出力すること
配列内に1,2,3の全てが入っていない場合は、「False」と出力すること
雛形

def array123(nums)
  # 処理を記述
end

# 呼び出し例
array123([1, 1, 2, 3, 1])
出力例
array123([1, 1, 2, 3, 1]) → True
array123([1, 2, 4, ]) → False
array123([1, 1, 2, 1, 4, 3]) → True

ヒント
include?メソッドを使用しましょう。

include?メソッド
include?メソッドは指定した値が、配列中に含まれているかを判定するメソッドです。指定した値が含まれている場合はtrueを、含まれていない場合はfalseを返り値として返します。


array = ["foo", "bar"]
puts array.include?("bar")
#=> true
puts array.include?("hoge")
#=> false
include?メソッドの詳細は公式リファレンスを確認しましょう。

ーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー

def array123(nums)
    if num.include?(1) && nums.include?(2) && nums.include?(3)
      puts "True"
    else 
      puts "False"
    end
  puts count
end

# 呼び出し例
array123([1, 1, 2, 3, 1])
出力例
array123([1, 1, 2, 3, 1]) → True
array123([1, 2, 4, ]) → False
array123([1, 1, 2, 1, 4, 3]) → True


問題20

概要
本ドリルでは、指定された2つの真偽値によって処理が異なるプログラムを実装します。

問題
Aさんは普段土日が休みの仕事に就いており、休みの日は遅くまで寝ていたいと考えています。
そこで、Aさんのために「その日が遅くまで寝ていられるかどうか」を判断する、sleep_inメソッドを実装しましょう。

第一引数の値では「平日かどうか」、第二引数の値では「休暇かどうか」をtrueまたはfalseを用いて以下のように表します。

第一引数がtrue（平日である）または、第二引数がtrue（休暇である）の場合はtrueと出力する
第一引数がfalse（平日でない）または、第二引数がtrue（休暇である）の場合はtrueと出力する
第一引数がtrue（平日である）または、第二引数がfalse（休暇でない）の場合はfalseと出力する
第一引数がfalse（平日でない）または、第二引数がfalse（休暇でない）の場合はtrueと出力する
雛形

def sleep_in(is_weekday, is_vacation)
  # ここに条件式を実装する
end

# 呼び出し例
sleep_in(false, false)
出力例
sleep_in(false, false) → true
sleep_in(true, false) → false
sleep_in(false, true) → true

ーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー

def sleep_in(is_weekday, is_vacation)
  if (is_weekday != true) || (is_vacation == true)
    puts true
  else
    puts false
  end
end

# 呼び出し例
sleep_in(false, false)